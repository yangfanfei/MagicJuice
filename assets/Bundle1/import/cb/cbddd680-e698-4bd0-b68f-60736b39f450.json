[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"water-wave",[{"hash":2059035201,"record":null,"name":"water-wave|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform Properties {\n  vec4 colors[6];\n  vec4 heights[6];\n  vec2 iResult;\n  float tiltAngle;\n  float corrugationType;\n};\nvec2 tranPt(vec2 uv,float angle,vec2 center){\n  float c = cos(angle);\n  float s = sin(angle);\n  float Ox = center.x;\n  float Oy = center.y;\n  mat3 m = mat3(\n        c,0.0-s,(1.0-c)*Ox+s*Oy,\n        s,c,(1.0-c)*Oy-s*Ox,\n        0.0,0.0,1.0\n  );\n  vec3 ret = m*vec3(uv.x,uv.y,0.0);\n  return ret.xy;\n}\nfloat drawWater(vec2 uv,float angle,float _height,int arrSize,int curIdx)\n{\n  float ratio = iResult.y/iResult.x;\n  bool toLeft = sin(angle)>=0.0;\n  vec2 center = vec2(0.5,1.0-_height);\n  float _t = abs(tan(angle));\n  if(_height<0.5){\n    bool is_bottom = _t/ratio>2.0*_height;\n    if(is_bottom){\n      center.x = sqrt(2.0*_height/_t*ratio)/2.0;\n      center.y = 1.0 - sqrt(2.0*_height*_t/ratio)/2.0;\n      bool is_top = _t>(ratio)/(_height*2.0);\n      if(is_top){\n        center.y = 0.5;\n        center.x = _height;\n      }\n    }\n    if(!toLeft){\n      center.x = 1.0-center.x;\n    }\n  }else{\n    bool is_top = _t>2.0*ratio*(1.0-_height);\n    if(is_top){\n      center.x = sqrt(2.0*ratio*(1.0-_height)/_t)/2.0;\n      center.y = sqrt(2.0*ratio*(1.0-_height)*_t)/2.0/ratio;\n      bool is_bottom = _t>ratio/(2.0*(1.0-_height));\n      if(is_bottom){\n        center.y = 0.5;\n        center.x = 1.0-_height;\n      }\n    }\n    if(toLeft){\n      center.x = 1.0-center.x;\n    }\n  }\n  uv.y = uv.y*ratio;\n  uv -= vec2(center.x,center.y*ratio);\n  vec2 uv1 = tranPt(uv,angle,vec2(0.0));\n  float y = 0.0;\n  bool hasWave = curIdx==arrSize-1;\n  hasWave = hasWave;\n  if(hasWave){\n    float amplitude = 0.0;\n    float angularVelocity = 0.0;\n    float frequency = 0.0;\n    if(abs(corrugationType-1.0)<0.01){\n      amplitude = 0.08;\n      angularVelocity = 10.0;\n      frequency = 10.0;\n    }else if(abs(corrugationType-2.0)<0.01){\n      amplitude = 0.03;\n      angularVelocity = 5.0;\n      frequency = 6.0;\n    }\n    y = amplitude * sin((angularVelocity * uv1.x) + (frequency * cc_time.x)*(toLeft ? 1. : -1.));\n  }\n  float alpha = (uv1.y > y) ? 1.0 : 0.0;\n  return alpha;\n}\nvoid main () {\n  vec4 ret = vec4(1.0,1.0,1.0,1.0);\n  ret *= texture(texture, v_uv0);\n  if(ret.a == 0.0){\n    discard;\n  }\n  float angle = mod(tiltAngle,360.0) * 3.14159265358979323846 / 180.0;\n  vec2 uv = vec2(v_uv0);\n  float a = 0.0;\n  float _height = 0.0;\n  int size = 0;\n  for(int i=0;i<6;i++){\n    if(heights[i].x<0.001){\n      continue;\n    }\n    size++;\n  }\n  for(int i=0;i<6;i++){\n    if(heights[i].x<0.001){\n      continue;\n    }\n    _height+=heights[i].x;\n    a += drawWater(uv,angle,_height,size,i);\n    if(a>0.0){\n        ret *= a*colors[i];\n        break;\n    }\n  }\n  if(a<0.001){\n    discard;\n  }\n  gl_FragColor = ret;\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nuniform vec4 cc_time;\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform vec4 colors[6];\nuniform vec4 heights[6];\nuniform vec2 iResult;\nuniform float tiltAngle;\nuniform float corrugationType;\nvec2 tranPt(vec2 uv,float angle,vec2 center){\n  float c = cos(angle);\n  float s = sin(angle);\n  float Ox = center.x;\n  float Oy = center.y;\n  mat3 m = mat3(\n        c,0.0-s,(1.0-c)*Ox+s*Oy,\n        s,c,(1.0-c)*Oy-s*Ox,\n        0.0,0.0,1.0\n  );\n  vec3 ret = m*vec3(uv.x,uv.y,0.0);\n  return ret.xy;\n}\nfloat drawWater(vec2 uv,float angle,float _height,int arrSize,int curIdx)\n{\n  float ratio = iResult.y/iResult.x;\n  bool toLeft = sin(angle)>=0.0;\n  vec2 center = vec2(0.5,1.0-_height);\n  float _t = abs(tan(angle));\n  if(_height<0.5){\n    bool is_bottom = _t/ratio>2.0*_height;\n    if(is_bottom){\n      center.x = sqrt(2.0*_height/_t*ratio)/2.0;\n      center.y = 1.0 - sqrt(2.0*_height*_t/ratio)/2.0;\n      bool is_top = _t>(ratio)/(_height*2.0);\n      if(is_top){\n        center.y = 0.5;\n        center.x = _height;\n      }\n    }\n    if(!toLeft){\n      center.x = 1.0-center.x;\n    }\n  }else{\n    bool is_top = _t>2.0*ratio*(1.0-_height);\n    if(is_top){\n      center.x = sqrt(2.0*ratio*(1.0-_height)/_t)/2.0;\n      center.y = sqrt(2.0*ratio*(1.0-_height)*_t)/2.0/ratio;\n      bool is_bottom = _t>ratio/(2.0*(1.0-_height));\n      if(is_bottom){\n        center.y = 0.5;\n        center.x = 1.0-_height;\n      }\n    }\n    if(toLeft){\n      center.x = 1.0-center.x;\n    }\n  }\n  uv.y = uv.y*ratio;\n  uv -= vec2(center.x,center.y*ratio);\n  vec2 uv1 = tranPt(uv,angle,vec2(0.0));\n  float y = 0.0;\n  bool hasWave = curIdx==arrSize-1;\n  hasWave = hasWave;\n  if(hasWave){\n    float amplitude = 0.0;\n    float angularVelocity = 0.0;\n    float frequency = 0.0;\n    if(abs(corrugationType-1.0)<0.01){\n      amplitude = 0.08;\n      angularVelocity = 10.0;\n      frequency = 10.0;\n    }else if(abs(corrugationType-2.0)<0.01){\n      amplitude = 0.03;\n      angularVelocity = 5.0;\n      frequency = 6.0;\n    }\n    y = amplitude * sin((angularVelocity * uv1.x) + (frequency * cc_time.x)*(toLeft ? 1. : -1.));\n  }\n  float alpha = (uv1.y > y) ? 1.0 : 0.0;\n  return alpha;\n}\nvoid main () {\n  vec4 ret = vec4(1.0,1.0,1.0,1.0);\n  ret *= texture2D(texture, v_uv0);\n  if(ret.a == 0.0){\n    discard;\n  }\n  float angle = mod(tiltAngle,360.0) * 3.14159265358979323846 / 180.0;\n  vec2 uv = vec2(v_uv0);\n  float a = 0.0;\n  float _height = 0.0;\n  int size = 0;\n  for(int i=0;i<6;i++){\n    if(heights[i].x<0.001){\n      continue;\n    }\n    size++;\n  }\n  for(int i=0;i<6;i++){\n    if(heights[i].x<0.001){\n      continue;\n    }\n    _height+=heights[i].x;\n    a += drawWater(uv,angle,_height,size,i);\n    if(a>0.0){\n        ret *= a*colors[i];\n        break;\n    }\n  }\n  if(a<0.001){\n    discard;\n  }\n  gl_FragColor = ret;\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"Properties","binding":1,"members":[{"name":"colors","type":16,"count":6},{"name":"heights","type":16,"count":6},{"name":"iResult","type":14,"count":1},{"name":"tiltAngle","type":13,"count":1},{"name":"corrugationType","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"water-wave|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]}}}]}]]],0,0,[],[],[]]